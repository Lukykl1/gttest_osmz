#include "gthr.h"

#define DEBUG_SIGNAL_SCALE 1

long get_time_us(void)
{
  struct timespec ts;
  timespec_get(&ts, TIME_UTC);
  return (long)ts.tv_sec * 1000000L + ts.tv_nsec / 1000; //us
}

// function triggered periodically by timer (SIGALRM)
void gthandle(int sig)
{
  gtyield();
}

// initialize first thread as current context
void gtinit(void)
{
  gtcur = &gttbl[0];   // initialize current thread with thread #0
  gtcur->st = Running; // set current to running
  gtcur->stats.last_start = get_time_us();
  gt_started = get_time_us();
  signal(SIGALRM, gthandle); // register SIGALRM, signal from timer generated by alarm
}

// exit thread
void __attribute__((noreturn)) gtret(int ret)
{
  if (gtcur != &gttbl[0])
  {                       // if not an initial thread,
    gtcur->st = Unused;   // set current thread as unused
    gtyield();            // yield and make possible to switch to another thread
    assert(!"reachable"); // this code should never be reachable ... (if yes, returning function on stack was corrupted)
  }
  while (gtyield())
    ; // if initial thread, wait for other to terminate
  exit(ret);
}

// switch from one thread to other
bool gtyield(void)
{
  struct gt *p;
  struct gtctx *old, *new;

  resetsig(SIGALRM); // reset signal

  p = gtcur;
  while (p->st != Ready)
  {                                 // iterate through gttbl[] until we find new thread in state Ready
    if (++p == &gttbl[MaxGThreads]) // at the end rotate to the beginning
      p = &gttbl[0];
    if (p == gtcur) // did not find any other Ready threads
      return false;
  }

  if (gtcur->stats.last_start != 0) //never run before
  {
    long run_time = get_time_us() - gtcur->stats.last_start;
    //printf("DEBUG: switch runtime: %ld now: %ld last_start %ld \n", run_time, get_time_us(), gtcur->stats.last_start);
    gtcur->stats.last_sleep = get_time_us();
    gtcur->stats.total_run_time += run_time;
    if (run_time > gtcur->stats.max_run_time)
    {
      gtcur->stats.max_run_time = run_time;
    }
    if (run_time < gtcur->stats.min_run_time  || gtcur->stats.min_run_time==0)
    {
      gtcur->stats.min_run_time = run_time;
    }
  }
  if (gtcur->st != Unused) // switch current to Ready and new thread found in previous loop to Running
    gtcur->st = Ready;
  p->st = Running;
  old = &gtcur->ctx; // prepare pointers to context of current (will become old)
  new = &p->ctx;     // and new to new thread found in previous loop
  gtcur = p;         // switch current indicator to new thread
  gtswtch(old, new); // perform context switch (assembly in gtswtch.S)

  long wait_time = get_time_us() - gtcur->stats.last_sleep;
  //printf("DEBUG: switch wait_time: %ld now: %ld last_sleep %ld \n", wait_time, get_time_us(), gtcur->stats.last_sleep);
  gtcur->stats.count_of_waits++;
  gtcur->stats.last_start = get_time_us();
  gtcur->stats.total_waiting_time += wait_time;
  if (wait_time > gtcur->stats.max_wait_time)
  {
    gtcur->stats.max_wait_time = wait_time;
  }
  if (wait_time < gtcur->stats.min_wait_time || gtcur->stats.min_wait_time==0)
  {
    gtcur->stats.min_wait_time = wait_time;
  }

  return true;
}

// return function for terminating thread
void gtstop(void)
{
  gtret(0);
}

// create new thread by providing pointer to function that will act like "run" method
int gtgo(void (*f)(void))
{
  char *stack;
  struct gt *p;

  for (p = &gttbl[0];; p++)       // find an empty slot
    if (p == &gttbl[MaxGThreads]) // if we have reached the end, gttbl is full and we cannot create a new thread
      return -1;
    else if (p->st == Unused)
      break; // new slot was found

  stack = malloc(StackSize); // allocate memory for stack of newly created thread
  if (!stack)
    return -1;

  *(uint64_t *)&stack[StackSize - 8] = (uint64_t)gtstop; //	put into the stack returning function gtstop in case function calls return
  *(uint64_t *)&stack[StackSize - 16] = (uint64_t)f;     //  put provided function as a main "run" function
  p->ctx.rsp = (uint64_t)&stack[StackSize - 16];         //  set stack pointer
  p->st = Ready;                                         //  set state
  p->stats.last_sleep = get_time_us();

  return 0;
}

void resetsig(int sig)
{
  if (sig == SIGALRM)
  {
    alarm(0); // Clear pending alarms if any
  }

  sigset_t set;         // Create signal set
  sigemptyset(&set);    // Clear it
  sigaddset(&set, sig); // Set signal (we use SIGALRM)

  sigprocmask(SIG_UNBLOCK, &set, NULL); // Fetch and change the signal mask

  if (sig == SIGALRM)
  {
    // Generate alarms
    ualarm(500 * DEBUG_SIGNAL_SCALE, 500 * DEBUG_SIGNAL_SCALE); // Schedule signal after given number of microseconds
  }
}

int uninterruptibleNanoSleep(time_t sec, long nanosec)
{
  struct timespec req;
  req.tv_sec = sec;
  req.tv_nsec = nanosec;

  do
  {
    if (0 != nanosleep(&req, &req))
    {
      if (errno != EINTR)
        return -1;
    }
    else
    {
      break;
    }
  } while (req.tv_sec > 0 || req.tv_nsec > 0);
  return 0; /* Return success */
}
